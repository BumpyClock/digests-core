You are the coding agent working in /Users/adityasharma/Projects/digests-core (Rust). Approval policy is "never" (no escalations). Follow ~/.claude/docs/writing-code.md (ABOUTME headers, minimal changes, no mocks, no --no-verify). Read plan in .ai_agents/porting_plan.md and ABI contracts in .ai_agents/structs.md. API reference fixtures live in api_reference_responses/ (do not modify them). ReaderView/metadata will be done later; this task is feed-only scaffolding and utilities.

Goal for this task
- Scaffold the Rust workspace and initial feed utilities, but DO NOT yet implement the full feed parser logic. Just create structure and helper functions/tests.

Decisions already made (do not change)
- Workspace members: crates/feed, crates/ffi.
- Rust edition 2021. Use chrono for time handling. Use feed-rs for parsing later (add dep now). Use scraper + url for HTML/image parsing. Use parse_duration crate for Go-like duration strings. No async needed yet.
- FFI crate: stub only so workspace builds; implement full ABI later.

What to implement now
1) Root setup
   - Create root Cargo.toml as a workspace with members ["crates/feed", "crates/ffi"].
   - Add .gitignore to exclude /target, /dist, **/Cargo.lock (but keep if already present), .DS_Store, *.swp.
   - Add cbindgen.toml at repo root with basic config: language = "C", include version, header = "// generated by cbindgen"; crate = "ffi"; output later to dist/digests.h.

2) crates/feed
   - Cargo.toml: package name "digests-feed", edition 2021. Dependencies: feed-rs = "1" (for later), chrono = { version = "0.4", features = ["serde", "clock"] }, scraper = "0.17", url = "2", parse_duration = "2", serde = { version = "1", features=["derive"] } (for potential fixture decoding), anyhow = "1" (for future). Dev-deps: pretty_assertions = "1".
   - src/lib.rs with ABOUTME header; declare pub modules: time_parse, duration_parse, html_utils, image_utils. Re-export key fns: parse_flexible_time, parse_duration_seconds, strip_html, decode_entities, extract_first_image, is_valid_image_url, resolve_image_url.
   - Implement modules:
     a) time_parse.rs: implement pub fn parse_flexible_time(s: &str) -> Option<chrono::DateTime<chrono::Utc>> matching Go list in porting_plan (RFC3339, RFC3339Nano, RFC1123, RFC1123Z, RFC822, RFC822Z, "2006-01-02T15:04:05Z07:00", "2006-01-02T15:04:05", "2006-01-02 15:04:05", "2006-01-02", "02 Jan 2006 15:04:05 MST", "02 Jan 2006 15:04:05 -0700", "Mon, 02 Jan 2006 15:04:05 MST", "Mon, 02 Jan 2006 15:04:05 -0700", "Mon, 2 Jan 2006 15:04:05 MST", "Mon, 2 Jan 2006 15:04:05 -0700"). Trim input; try formats in order; return UTC; if timezone missing assume UTC. Use chrono::NaiveDateTime where needed.
     b) duration_parse.rs: pub fn parse_duration_seconds(s: &str) -> Option<u32>. Behavior: empty -> None; if int string -> that value; try parse_duration::parse(s) -> duration; also support HH:MM:SS and MM:SS. Return seconds as u32 if fits; else None.
     c) html_utils.rs: implement strip_html (naive removal like Go), decode_entities using the same map as src/pkg/utils/html/strip.go. Keep functions pub fn strip_html(s: &str) -> String and pub fn decode_entities(s: &str) -> String.
     d) image_utils.rs: use scraper to parse HTML; pub fn extract_first_image(html: &str, base_url: Option<&str>) -> Option<String>. Find first <img src> that passes is_valid_image_url; resolve relative via resolve_image_url (below). Also implement pub fn resolve_image_url(src: &str, base_url: Option<&str>) -> Option<String> using url::Url. Implement pub fn is_valid_image_url(u: &str) -> bool using the same filters as Go: skip if contains (case-insensitive) pixel, tracking, analytics, beacon, spacer, clear.gif, blank.gif, 1x1, data:image/gif;base64,r0lgodlhaqabai; skip if width=1 or height=1 in query/URL string. Allow others.

   - Tests (crates/feed/tests/utils_tests.rs):
     * parse_flexible_time parses RFC3339 and "Mon, 02 Jan 2006 15:04:05 MST"; missing timezone date "2006-01-02 15:04:05" yields UTC naive.
     * duration_parse covers "123", "01:02:03" -> 3723, "05:30" -> 330, "1h30m" -> 5400.
     * strip_html removes tags and decodes &amp; &nbsp;; maintains simple whitespace collapse.
     * image_utils is_valid_image_url rejects tracking pixel URL and accepts normal jpg; resolve_image_url makes relative path absolute with base.

3) crates/ffi
   - Cargo.toml: package name "digests-ffi", edition 2021, crate-type = ["staticlib", "cdylib"]. Dependencies: bumpalo = "3", libc = "0.2", chrono = { version = "0.4", features=["clock"] }, digests-feed = { path = "../feed" }. (No cbindgen dep needed.)
   - src/lib.rs with ABOUTME header; for now expose minimal stubs so workspace builds: const DIGESTS_FFI_VERSION: u32 = 1; #[no_mangle] pub extern "C" fn digests_ffi_version() -> u32 { DIGESTS_FFI_VERSION }. Define placeholder repr(C) structs DString { data: *const u8, len: usize } to match structs.md, but do NOT implement parsing yet. Add a compile-only test if helpful.

General rules
- Use apply_patch for edits. Keep comments minimal. Do not touch api_reference_responses files. Do not implement feed parsing yet.
- Ensure all new Rust files start with two ABOUTME lines per writing-code.md.
- Workspace should `cargo check` successfully after this task.

Deliverable: code committed to workspace (no git commit) that builds. EOF